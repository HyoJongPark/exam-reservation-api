# exam-reservation-api

## 1. 프로젝트 개요

이 프로젝트는 **사용자의 예약 신청, 예약 정보 조회, 예약 확정 및 수정/삭제 기능을 제공**하는 FastAPI 기반의 웹 애플리케이션입니다.

### 주요 기능

- 예약 가능 시간/인원 조회
- 사용자/관리자의 예약 등록, 조회, 수정, 삭제
- 동시 예약 확정 시 정합성 유지
- 예약 인원 5만명 초과 여부 검증 및 예외 처리

### 기술 스택

- 프레임워크: FastAPI
- 언어: Python 3.12
- 데이터베이스: PostgreSQL (Docker 기반)
- ORM: SQLAlchemy
- 테스트: pytest + Thread 기반 정합성 테스트 포함
- 배포 환경: Docker

---

## 2. 설치 및 실행 방법

### 1) 프로젝트 클론

```
git clone https://github.com/HyoJongPark/exam-reservation-api.git
cd exam-reservation-api
```

### 2) 프로젝트 초기 설정

```
brew install pyenv
pyenv install 3.12.0

export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv init -)"

pyenv local 3.12.0
```

- 해당 프로젝트는 python version 3.12에서 작성되었습니다.
- 버전 문제로 실행되지 않은 시 `pyenv`를 사용해 프로젝트 환경에 맞는 버전을 설치하고, 재실행 시켜보시면 됩니다.

```
python -m venv venv
source ./venv/bin/activate  # macOS/Linux

pip install -r requirements.txt
```

- 가상환경을 설정합니다.

### 3) 프로젝트 실행

```
# 도커 실행 (DB)
docker compose -f docker-compose.yml up -d

# 파이썬 실행
PYTHONPATH=./app/src uvicorn main:app --reload
```

- DB는 도커 환경을 통해 실행됩니다. 따라서 도커 설치가 필요합니다.
- 도커 실행 후 파이썬 실행 명령어를 가상환경이 설정된 터미널 내에서 실행하면 API 호출이 가능합니다.

### 4) 테스트 실행

```
docker compose -f docker-compose.test.yml up -d  # 테스트환경 용 DB 실행
PYTHONPATH=. pytest  # 테스트 실행
```

---

## 3. API 문서

- Swagger 기반의 API 문서는 서버 실행 후 `http://localhost:8000/api-docs`에서 확인 가능합니다.
- Swagger를 통해 요청 응답을 수행할 수 있습니다.
  - 회원가입 -> 로그인 후 토큰 정보를 반환합니다.
  - 해당 정보를 API Docs 우측 상단 [Authorize] 버튼을 클릭해 기입하고, 인증을 수행할 수 있습니다.
  - 헤더를 설정하면 `reservations` api에 접근 가능합니다.
  - ex) `Authorization: Bearer token`

---

## 4. 데이터베이스 스키마

### `users` 테이블 구조

| 필드명     | 타입      | 설명                     |
| ---------- | --------- | ------------------------ |
| id         | INT (PK)  | 사용자 고유 ID           |
| user_name  | VARCHAR   | 사용자 이름              |
| email      | VARCHAR   | 사용자 이메일 (Unique)   |
| password   | VARCHAR   | 해시된 비밀번호          |
| role       | VARCHAR   | 사용자 권한 (ADMIN/USER) |
| created_at | TIMESTAMP | 생성 일시                |
| updated_at | TIMESTAMP | 수정 일시                |

### `reservations` 테이블

| 필드명           | 타입      | 설명                          |
| ---------------- | --------- | ----------------------------- |
| id               | SERIAL PK | 예약 ID                       |
| user_id          | INT FK    | 사용자 ID                     |
| reservation_name | VARCHAR   | 예약 제목                     |
| start_time       | DATETIME  | 예약 시작 시간                |
| end_time         | DATETIME  | 예약 종료 시간                |
| number_of_people | INT       | 예약 인원                     |
| status           | ENUM      | 예약 상태 (대기/확정/취소 등) |
| created_at       | TIMESTAMP | 생성 시간                     |
| updated_at       | TIMESTAMP | 수정 시간                     |

---

## 6. 기능 설명

### A. 권한 구분 및 API 구조

- **어드민과 일반 사용자**는 역할에 따라 수행할 수 있는 기능에 차이가 있습니다. 예를 들어, 어드민은 예약이 확정된 후에도 수정/삭제가 가능하지만, 일반 사용자는 예약이 확정되면 해당 리소스를 수정하거나 삭제할 수 없습니다.
- 이러한 차이를 고려하여 어드민 전용 API 엔드포인트(`/admin/reservations`)를 별도로 분리하는 방안도 고려했지만, 현재는 다음과 같은 이유로 모든 예약 관련 기능을 하나의 엔드포인트(`/reservations`)로 통합해 관리하고 있습니다:

  - **로직 중복 최소화**: 어드민과 사용자 모두 유사한 로직을 공유하므로, 하나의 엔드포인트에서 역할별 분기를 통해 처리하는 것이 중복을 줄일 수 있습니다.
  - **관리의 일관성**: 여러 엔드포인트로 분리하면 비슷한 기능을 위한 여러 API가 생겨나고, 이는 유지보수와 테스트에 있어 오히려 복잡성을 증가시킬 수 있습니다.
  - **협업 효율성**: 단일 API 구조는 프론트엔드 개발자와의 협업 시 명세 공유가 간단하며, 관리자의 화면도 동일한 API 기반으로 빠르게 구축할 수 있습니다.

#### 📌 향후 API 분리를 고려할 기준

아래와 같은 조건이 충족되는 시점에서는 어드민 전용 API를 분리하는 것이 더 적합할 수 있습니다:

- 어드민 기능이 사용자 기능과 명확히 달라지고, 별도 UI 또는 비즈니스 로직이 추가되는 경우
- 어드민 서비스가 별도 도메인 혹은 관리자 전용 시스템으로 운영되는 경우
- 라우터 단에서 보안상 이유로 접근 제어를 명확히 해야 하는 경우

현재는 단일 구조로 운영하면서도 역할에 따라 로직을 분기하여 처리하고 있으며, 위와 같은 조건이 충족되는 시점에 구조 리팩토링을 고려할 계획입니다.

### B. 예약 확정 시 정합성 유지

- 관리자에 의한 예약 확정 시, 다른 요청과의 **동시성 문제로 인해 5만명 제한을 초과할 수 있는 상황을 방지**해야 합니다.
- 이를 위해 `with_for_update()`를 활용한 **비관적 락**을 적용했습니다.
  - 해당 시간 범위와 겹치는 모든 예약들을 조회(예약 상태 무관)하고, 이들에 대해 update lock을 겁니다.
  - 이를 통해 동시에 확정되거나 갱신되는 데이터로 인해 제한 사항을 초과할 수 있는 문제를 방지합니다.
  - 낙관적 락을 추가로 고려했지만, 여러 예약 정보에 동시에 lock을 걸어야 하기 때문에 충돌 가능성이 크다고 판단했고 비관적 락을 사용한 정합성 유지를 선택했습니다.
- [🔗 정합성 테스트](https://github.com/HyoJongPark/exam-reservation-api/blob/main/tests/reservation/service_integeration_test.py)를 통해 다수의 동시 확정 요청 상황에서도 제한 인원 초과가 발생하지 않음을 검증합니다.

---

### 📌 과제 요구사항

- [x] 사용자은 예약 신청이 가능한 시간/인원을 알 수 있다.
  - [x] 시작, 종료 구간을 Date(YYYY-MM-DD)로 입력받는다.
    - 입력 포맷과 맞지않는 입력은 예외발생
    - 시작, 종료 일자는 동일하거나 종료 일자가 더 커야한다.
  - [x] 현재 예약된 인원이란 어드민에 의해 예약 확정된 인원만을 포함한다.
  - [x] 응답은 10분 단위로 구성되고, 만약 다음 구간의 예약 가능 인원이 동일하다면 해당 구간들을 합해서 반환한다.
    - ex> (12:10 ~ 12:20: 40,000), (12:20 ~ 12:30: 40,000) 일 때 → (12:10 ~ 12:30: 40,000)을 반환함
  - [x] 예약이 불가한 구간은 응답에 포함되지 않는다.
- [x] 사용자는 (자신의) 특정 예약 정보를 조회할 수 있다.
  - 예약 ID를 쿼리 스트링으로 입력받는다.
  - 어드민은 모든 예약을 조회 가능하다.
  - 고객은 자신의 예약을 조회 가능하다.
    - 본인의 예약이외의 예약 정보 조회 시 예외 발생
  - 존재하지 않는 예약 조회 시 예외발생
- [x] 사용자는 (자신의) 예약 정보들을 조회할 수 있다.
  - [x] 시작, 종료 구간을 Date(YYYY-MM-DD)로 입력받는다.
    - 입력 포맷과 맞지않는 입력은 예외발생
    - 시작, 종료 일자는 동일하거나 종료 일자가 더 커야한다.
  - [x] 어드민은 모든 예약을 조회 가능하다.
  - [x] 고객은 자신의 예약만을 조회 가능하다.
  - [x] 응답은 해당 구간 사이의 조회 가능한 모든 예약 정보를 포함한다.
- [x] 사용자는 예약이 가능한 구간 내에서 예약을 진행할 수 있다.
  - [x] 예약 시간, 예약 인원을 입력받는다.
    - 예약 시간은 Datetime(YYYY-MM-DD HH:MM)의 형식으로 구성되어야 한다.
    - 입력 포맷과 맞지 않는 입력은 예외 발생
    - 예약 인원은 최소 1명, 최대 5만명 사이여야 한다.
  - [x] 최대 5만명의 예약을 수용 가능하다.
    - 구간 내에 5만명의 제한을 초과하는 구간이 존재하면 예외 발생
    - 확정되지 않은 예약은 5만명의 제한에 포함하지 않는다.
  - [x] 사용자는 현재 일자로부터 3일 뒤의 예약만이 가능하다.
    - 3일 이내 예약 시 예외 발생
- [x] 어드민은 고객의 대기 상태 예약을 확정할 수 있다.
  - [x] 예약 ID를 쿼리 스트링으로 입력받는다.
  - [x] 일반 사용자가 요청 시 예외 발생
  - [x] 5만건이 넘는 예약에 대해서는 예약 실패 응답을 반환한다.
  - [x] 동시 요청에 대해서도 5만건 정합성을 유지해야한다.
- [x] 사용자는 자신의 예약 정보를 수정할 수 있다.
  - [x] 예약 시간, 인원을 입력받는다.
    - 예약 시간, 인원 중 하나는 반드시 입력되어야하고, 입력되지 않으면 예외 발생
    - 예약 시간은 Datetime(YYYY-MM-DD HH:MM)의 형식으로 구성되어야 한다.
    - 예약 인원은 최소 1명, 최대 5만명 사이여야 한다.
  - [x] 사용자는 예약 확정 전인 예약에 대해 수정이 가능하다.
  - [x] 어드민은 모든 고객의 예약을 수정 가능하다.(예약 확정 포함)
  - [x] 예약 수정 시 인원 및 시간이 수정된다면, 구간 내에 5만명의 제한을 초과해서는 안된다.
- [x] 사용자는 자신의 예약 정보를 삭제할 수 있다.
  - [x] 예약 ID를 쿼리 스트링으로 입력받는다.
  - [x] 고객은 확정 전 본인의 예약을 삭제할 수 있다.
  - [x] 어드민은 모든 고객의 예약을 삭제할 수 있다.
